diff --git b/virdant/src/lib.rs a/virdant/src/lib.rs
index ba4b87c..f227850 100644
--- b/virdant/src/lib.rs
+++ a/virdant/src/lib.rs
@@ -2,6 +2,7 @@ pub mod parse;
 pub mod error;
 pub mod id;
 pub mod types;
+pub mod expr;
 pub mod ast;
 pub mod location;
 
@@ -13,6 +14,7 @@ mod cycle;
 mod tests;
 
 use cycle::detect_cycle;
+use expr::Expr;
 use indexmap::IndexMap;
 use indexmap::IndexSet;
 use parse::QualIdent;
@@ -23,6 +25,7 @@ use id::*;
 use ast::Ast;
 use types::CtorSig;
 use std::hash::Hash;
+use std::sync::Arc;
 use table::Table;
 use types::Type;
 
@@ -45,20 +48,22 @@ pub struct Virdant {
     ctors: Table<Ctor, CtorInfo>,
     portdefs: Table<PortDef, PortDefInfo>,
     channels: Table<Channel, ChannelInfo>,
+    components: Table<Component, ComponentInfo>,
+    exprroots: Table<ExprRoot, ExprRootInfo>,
 }
 
 #[derive(Default, Clone, Debug)]
 struct PackageInfo {
     name: String,
     source: std::path::PathBuf,
-    ast: Ready<Ast<'static>>,
+    ast: Ready<Ast>,
 }
 
 #[derive(Default, Clone, Debug)]
 struct ItemInfo {
     name: String,
     package: Ready<Id<Package>>,
-    ast: Ready<Ast<'static>>,
+    ast: Ready<Ast>,
     kind: Ready<ItemKind>,
     deps: Ready<Vec<Id<Item>>>,
 }
@@ -111,6 +116,14 @@ struct ComponentInfo {
     is_reg: Ready<bool>,
 }
 
+#[derive(Default, Clone, Debug)]
+struct ExprRootInfo {
+    moddef: Ready<Id<ModDef>>,
+    ast: Ready<Ast>,
+    expr: Ready<Arc<Expr>>,
+    typ: Ready<Type>,
+}
+
 
 ////////////////////////////////////////////////////////////////////////////////
 // Public Virdant API
@@ -165,6 +178,8 @@ impl Virdant {
         self.register_portdefs();
         self.register_components();
 
+//        self.register_exprroots();
+
         self.errors.clone().check()
     }
 }
@@ -190,8 +205,7 @@ impl Virdant {
             match self.package_text(package) {
                 Err(err) => self.errors.add(err),
                 Ok(text) => {
-                    let text: &'static str = text.leak(); // TODO
-                    let result: Result<Ast, _> = parse::parse_package(text);
+                    let result: Result<Ast, _> = parse::parse_package(&text);
                     match result {
                         Ok(package_ast) => {
                             let package_info = &mut self.packages[package];
@@ -225,7 +239,7 @@ impl Virdant {
         }
     }
 
-    fn register_item(&mut self, item_ast: Ast<'static>, package: Id<Package>) {
+    fn register_item(&mut self, item_ast: Ast, package: Id<Package>) {
         let item_name = item_ast.name().unwrap();
         let qualified_item_name = format!("{package}::{item_name}");
         let item: Id<Item> = Id::new(qualified_item_name.clone());
@@ -660,6 +674,154 @@ impl Virdant {
 }
 
 
+////////////////////////////////////////////////////////////////////////////////
+// Components and Expressions
+////////////////////////////////////////////////////////////////////////////////
+
+impl Virdant {
+    fn register_components(&mut self) {
+        let moddefs = self.moddefs();
+
+        for moddef in moddefs {
+            let moddef_ast = self.items[moddef.as_item()].ast.unwrap().child(0);
+            for node in moddef_ast.children() {
+                if node.is_statement() {
+                    if node.child(0).is_component() {
+                        let component_name = node.name().unwrap();
+                        let component_typ_ast = node.typ().unwrap();
+                        eprintln!("  COMPONENT: {component_name:?} : {:?}", component_typ_ast.summary());
+
+                        let component: Id<Component> = Id::new(format!("{moddef}::{component_name}"));
+                        let component_info = self.components.register(component);
+
+                        component_info.moddef.set(moddef);
+                        component_info.path = vec![component_name.to_string()];
+                        component_info.is_reg.set(node.is_reg());
+                        if let Ok(typ) = self.resolve_type(component_typ_ast, moddef.as_item()) {
+                            let component_info = &mut self.components[component];
+                            component_info.typ.set(typ);
+                        }
+                    } else if node.child(0).is_submodule() {
+                        let submodule_name = node.name().unwrap();
+                        let submodule_moddef_name = node.of().unwrap();
+                        match self.resolve_moddef(submodule_moddef_name, moddef.as_item()) {
+                            Ok(submodule_moddef) => {
+                                self.register_submodule_components(submodule_name, submodule_moddef, moddef);
+                            },
+                            Err(err) => {
+                                self.errors.add(err);
+                            },
+                        }
+                    } else if node.child(0).is_port() {
+                        let port_name = node.name().unwrap();
+                        let port_portdef_name = node.of().unwrap();
+                        match self.resolve_portdef(port_portdef_name, moddef.as_item()) {
+                            Ok(portdef) => {
+                            let path = vec![port_name.to_string()];
+                                self.register_port_components(path, portdef, moddef);
+                            }, 
+                            Err(err) => self.errors.add(err),
+                        }
+                    } else if node.child(0).is_driver() {
+                        ()
+                    } else {
+                        unreachable!()
+                    }
+                }
+            }
+        }
+    }
+
+    fn register_submodule_components(&mut self, name: &str, submodule_moddef: Id<ModDef>, in_moddef: Id<ModDef>) {
+        eprintln!("  mod {name} of {submodule_moddef}");
+        let moddef_ast = self.items[submodule_moddef.as_item()].ast.unwrap().child(0);
+        for node in moddef_ast.children() {
+            if node.is_statement() {
+                let statement = node.child(0);
+                if statement.is_component() {
+                    if statement.is_implicit() || statement.is_incoming() || statement.is_outgoing() {
+                        let component_name = statement.name().unwrap();
+                        let component_typ_ast = statement.typ().unwrap();
+
+                        let component: Id<Component> = Id::new(format!("{in_moddef}::{name}.{component_name}"));
+                        eprintln!("  COMPONENT: {component:?} : {:?}", component_typ_ast.summary());
+
+                        let component_info = self.components.register(component);
+                        component_info.moddef.set(in_moddef);
+                        component_info.path = vec![name.to_string(), component_name.to_string()];
+                        component_info.is_reg.set(node.is_reg());
+                        if let Ok(typ) = self.resolve_type(component_typ_ast, submodule_moddef.as_item()) {
+                            let component_info = &mut self.components[component];
+                            component_info.typ.set(typ);
+                        }
+                    }
+                } else if statement.is_port() {
+                    let port_name = statement.name().unwrap();
+                    let port_portdef_name = statement.of().unwrap();
+                    match self.resolve_portdef(port_portdef_name, submodule_moddef.as_item()) {
+                        Ok(portdef) => {
+                            let path = vec![name.to_string(), port_name.to_string()];
+                            self.register_port_components(path, portdef, in_moddef);
+                        }, 
+                        Err(err) => self.errors.add(err),
+                    }
+                }
+            }
+        }
+    }
+
+    fn register_port_components(&mut self, path: Vec<String>, portdef: Id<PortDef>, in_moddef: Id<ModDef>) {
+        let portdef_info = &self.portdefs[portdef];
+        if let Ok(channels) = portdef_info.channels.get() {
+            for channel in channels {
+                let channel_info = &self.channels[*channel];
+
+                let channel_name = channel_info.name.clone();
+                let channel_typ = channel_info.typ.unwrap();
+
+                let name = format!("{}.{}", path.join("."), channel_name);
+                let component: Id<Component> = Id::new(format!("{in_moddef}::{name}"));
+                eprintln!("  COMPONENT: {component:?} : {:?}", channel_typ);
+
+                let component_info = self.components.register(component);
+                component_info.moddef.set(in_moddef);
+
+                let mut path = path.clone();
+                path.push(channel_name);
+                component_info.path = path;
+
+                component_info.is_reg.set(false);
+                component_info.typ.set(*channel_typ);
+            }
+        }
+    }
+
+    fn register_exprroots(&mut self) {
+        let moddefs = self.moddefs();
+        for moddef in moddefs {
+            let mut i = 0;
+            let moddef_ast = self.items[moddef.as_item()].ast.unwrap().child(0);
+            for node in moddef_ast.children() {
+                if node.is_statement() && node.child(0).is_driver() {
+                    let expr_id: Id<ExprRoot> = Id::new(format!("{moddef}::expr[{i}]"));
+                    i += 1;
+
+                    let exprroot_info = self.exprroots.register(expr_id);
+
+                    let driver_ast = node.child(0);
+                    let expr_ast = driver_ast.clone().expr().unwrap();
+                    exprroot_info.ast.set(expr_ast.clone());
+
+                    let expr = Expr::from_ast(expr_ast);
+                    eprintln!("expr= {expr:#?}");
+                    exprroot_info.expr.set(expr);
+                }
+            }
+        }
+    }
+}
+
+
 ////////////////////////////////////////////////////////////////////////////////
 // For testing
 ////////////////////////////////////////////////////////////////////////////////
@@ -670,13 +832,13 @@ impl Virdant {
         self.items.keys().cloned().collect()
     }
 
-    #[cfg(test)]
     fn moddefs(&self) -> Vec<Id<ModDef>> {
         let mut results = vec![];
         for item in self.items.keys() {
-            let item_ast = &self.items[*item].ast.unwrap();
-            if let Some(ItemKind::ModDef) = item_ast.item_kind() {
-                results.push(item.cast());
+            if let Ok(item_ast) = &self.items[*item].ast.get() {
+                if let Some(ItemKind::ModDef) = item_ast.item_kind() {
+                    results.push(item.cast());
+                }
             }
         }
         results
@@ -744,6 +906,23 @@ impl std::fmt::Debug for Virdant {
             writeln!(f, "        dir: {:?}", channel_info.dir)?;
         }
 
+        writeln!(f, "COMPONENTS:")?;
+        for (component, component_info) in self.components.iter() {
+            writeln!(f, "    {component}")?;
+            writeln!(f, "        moddef: {:?}", component_info.moddef)?;
+            writeln!(f, "        path: {}", component_info.path.join("."))?;
+            writeln!(f, "        typ: {:?}", component_info.typ)?;
+            writeln!(f, "        is_reg: {:?}", component_info.is_reg)?;
+        }
+
+        writeln!(f, "EXPRROOTS:")?;
+        for (exprroot, exprroot_info) in self.exprroots.iter() {
+            writeln!(f, "    {exprroot}")?;
+            writeln!(f, "        ast: {:?}", exprroot_info.ast.get().map(|ast| ast.summary()))?;
+            writeln!(f, "        expr: {:?}", exprroot_info.expr)?;
+            writeln!(f, "        typ: {:?}", exprroot_info.typ)?;
+        }
+
         Ok(())
     }
 }
