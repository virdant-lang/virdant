import types;
import rf;
import control;
import alu;
import immgen;
import decoder;
import ifetch;

fn mem_to_reg_data(data : Word[32], opcode : types::Opcode, funct3 : Word[3]) -> Word[32] {
    if opcode->eq(#LOAD) {
        if funct3->eq(0b000w5) {
            sext(data[8..0])
        } else if funct3->eq(0b100w3) {
            zext(data[8..0])
        } else if funct3->eq(0b001w3) {
            sext(data[16..0])
        } else if funct3->eq(0b101w3) {
            zext(data[16..0])
        } else if funct3->eq(0b010w3) {
            data
        } else {
            // TODO Impossible
            data
        }
    } else {
        data
    }
}

fn next_pc(opcode : types::Opcode, rs1_val : Word[32], imm : Word[32], alu_r : Word[32]) -> types::PcAdvancement {
    match opcode {
        #JALR => @Abs(rs1_val->add(imm));
        #JAL => @Offset(imm);
        #BRANCH =>
            if alu_r->eq(1) {
                @Offset(imm)
            } else {
                @Next()
            };
        else => @Next();
    }
}

/*
    `Core` is the top-level processor core.
*/
mod Core {
    incoming clock : Clock;
    incoming reset : Bit;

    mod rf of rf::Rf;
    mod control of control::Control;
    mod alu of alu::Alu;
    mod immgen of immgen::Immgen;
    mod decoder of decoder::Decoder;
    mod ifetch of ifetch::Ifetch;

    rf.clock := clock;

    ifetch.clock := clock;
    ifetch.reset := reset;

    outgoing ecall : Bit;
    outgoing ebreak : Bit;
    outgoing exception : Bit;

    outgoing instr_mem_addr : Word[32];
    incoming instr_mem_data : Word[32];

    // true when writing to memory
    outgoing mem_write_enable : Bit;
    outgoing mem_addr   : Word[32];
    outgoing mem_write_data   : Word[32];
    incoming mem_read_data    : Word[32];
    outgoing mem_write_mask   : Word[4];

    ecall     := decoder.opcode->eq(#SYSTEM)->and(decoder.funct12->eq(cat(#ECALL[types::SystemFunct12])));
    ebreak    := decoder.opcode->eq(#SYSTEM)->and(decoder.funct12->eq(cat(#EBREAK[types::SystemFunct12])));
    exception := decoder.exception;

    mem_addr  := rf.rs1_val->add(immgen.imm);
    mem_write_data := rf.rs2_val;
    mem_write_enable := control.mem_write;
    mem_write_mask := decoder.write_mask;

    ifetch.pc_advancement := next_pc(decoder.opcode, rf.rs1_val, immgen.imm, alu.r);

    instr_mem_addr := ifetch.instr_mem_addr;
    ifetch.instr_mem_data := instr_mem_data;

    rf.rs1 := decoder.rs1;
    rf.rs2 := decoder.rs2;
    rf.rd := decoder.rd;
    rf.write_enable := control.reg_write;
    rf.write_data := if control.mem_to_reg {
        mem_to_reg_data(mem_read_data, decoder.opcode, decoder.funct3)
    } else if decoder.opcode->eq(#LUI){
        immgen.imm
    } else if decoder.opcode->eq(#JAL)->or(decoder.opcode->eq(#JALR)) {
        ifetch.program_counter->add(4)
    } else {
        alu.r
    };

    decoder.instr := ifetch.instr;
    immgen.instr := ifetch.instr;
    immgen.opcode := decoder.opcode;

    control.opcode := decoder.opcode;
    control.funct3 := decoder.funct3;
    control.funct7 := decoder.funct7;
    control.funct12 := decoder.funct12;

    alu.a := rf.rs1_val;
    alu.b := match control.alu_source {
        #IMM => immgen.imm; 
        #RS2 => rf.rs2_val;
    };
    alu.op := control.alu_op;
}
